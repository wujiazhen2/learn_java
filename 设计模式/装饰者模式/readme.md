# 装饰者模式

装饰模式：装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。
它是通过创建一个包装对象，也就是装饰来包裹真实的对象

继承是静态扩展的,在编译时决定。装饰模式时动态扩展的。
组成：
1.抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。
2.具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。
3.装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。
4.具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。

![装饰模式](https://github.com/wujiazhen2/learn_java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/img/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.png?raw=true)



## 使用场景
1. 当扩展对象的功能是动态的，使用继承的方式会产生大量的子类。这时可以使用装饰模式。例如，一杯奶茶，可以加珍珠,椰果。而这些加料可以混搭。这时用继承的话就需要有
珍珠奶茶，椰果奶茶，珍珠椰果奶茶的实现类。如果加料的品类多了，需要实现的子类就成配增加。通过装饰实现，没增加一种配置增加一个装饰类既可以，见代码 {@link decorate.Client}

2. 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。  当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。